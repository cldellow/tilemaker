/*! \file */ 
#ifndef _OSM_MEM_TILES
#define _OSM_MEM_TILES

#include "tile_data.h"
#include "osm_store.h"
#include <map>
#include <memory>
#include <set>

#define OSM_THRESHOLD (1ull << 34)
#define USE_NODE_STORE (1ull << 34)
#define USE_WAY_STORE (2ull << 34)
#define USE_RELATION_STORE (3ull << 34)
#define IS_NODE(x) (((x) >> 34) == (USE_NODE_STORE >> 34))
#define IS_WAY(x) (((x) >> 34) == (USE_WAY_STORE >> 34))
#define IS_RELATION(x) (((x) >> 34) == (USE_RELATION_STORE >> 34))
#define OSM_ID(x) ((x) & 0b1111111111111111111111111111111111)

/**
	\brief OsmMemTiles stores OSM objects in memory and provides a vector of OutputObjectf for specified tiles
	
	The input objects are generated by PbfReader. The output objects are sent to OsmMemTiles for storage.

	This class provides a consistent interface for Lua scripts to access.
*/
class OsmMemTiles : public TileDataSource {

public:
	OsmMemTiles(
		size_t threadNum,
		uint baseZoom,
		bool includeID,
		const OSMStore& osmStore
	);

	LatpLon buildNodeGeometry(const OutputGeometryType geomType, const NodeID objectID, const TileBbox &bbox) const override;
	std::shared_ptr<Linestring> buildLinestring(const NodeID objectID) const override;
	MultiLinestring buildMultiLinestring(const NodeID objectID) const override;
	std::shared_ptr<MultiPolygon> buildMultiPolygon(const NodeID objectID) const override;

	void relationNeedsCorrection(RelationID id);

	void Clear();
	mutable std::map<uint64_t, uint64_t> freqs;

private:
	const OSMStore& osmStore;
	std::set<RelationID> relationsThatNeedCorrection;
	mutable std::mutex mutex;
	mutable std::vector<std::mutex> cacheMutex;
	mutable std::vector<std::map<uint64_t, std::shared_ptr<MultiPolygon>>> cachedPolygons;
	mutable std::vector<size_t> polygonCacheSize;
	mutable std::vector<std::map<uint64_t, std::shared_ptr<Linestring>>> cachedLinestrings;
	mutable std::vector<size_t> linestringCacheSize;

};

#endif //_OSM_MEM_TILES

